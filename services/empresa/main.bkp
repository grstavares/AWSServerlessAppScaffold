import { APIGatewayEvent, Callback, Context, Handler, APIGatewayProxyResult } from 'aws-lambda';
import { DynamoDB } from 'aws-sdk';

interface AWSErrorTyped {
    code: string            // a unique short code representing the error that was emitted.
    message: string         // a longer human readable error message
    retryable: boolean      // whether the error message is retryable.
    statusCode: number      // in the case of a request that reached the service, this value contains the response status code.
    time?: string            // the date time object when the error occurred.
    hostname?: string        // set when a networking error occurs to easily identify the endpoint of the request.
    region?: string          // set when a networking error occurs to easily identify the region of the request.
}

interface NoSQLError { statusCode: number, message: string }

// @ts-ignore
interface GetItemParams { (NoSQLError, any): void }

class NoSQL {

    private documentClient = new DynamoDB.DocumentClient();

    constructor(private endpoint?: string) {}

    getItem(tableName: string, itemId: string, callback: GetItemParams): void {
        
        console.log(`Get Item from ${tableName} using endpoint ${this.endpoint}`);
        const params: DynamoDB.DocumentClient.GetItemInput = {TableName: tableName, Key: {"id": itemId}};
        this.documentClient.get(params).promise().then(value => {

            const item = value.Item;
            if (item) {

                const response: APIGatewayProxyResult = {statusCode: 200, body: JSON.stringify(value.Item)}
                callback(null, response);

            } else {

                const err:NoSQLError = {statusCode: 404, message: 'Not Found' }
                const response: APIGatewayProxyResult = {statusCode: err.statusCode, body: JSON.stringify(err)}
                callback(null, response);

            }

        }).catch(reason => {
            
            const awserror: AWSErrorTyped = reason;
            const err:NoSQLError = {statusCode: 500, message: awserror.message }
            const response: APIGatewayProxyResult = {statusCode: err.statusCode, body: JSON.stringify(err)}
            callback(err, response);

        })
        
    }

}

function logResponse(context: Context, response: APIGatewayProxyResult): void {

    const logObject = {
        requestId: context.awsRequestId,
        response: response
    }

    console.log(logObject);

}

// @ts-ignore
export const handler: Handler = (event: APIGatewayEvent, context: Context, cb: Callback) => {
    
    const environment = process.env['DYNAMO_TABLE'];
    if (environment === undefined) {

        const response: APIGatewayProxyResult = { statusCode: 500, body: JSON.stringify({message: 'Backend Function not Configured'}) }
        logResponse(context, response);
        cb(null, response);

    } else {

        const method = event.httpMethod;

        switch (method) {

            case 'GET': {

                const tableName = environment.toString();
                if (!event.pathParameters || !event.pathParameters.empresaId) {

                    const resultCode = 400;
                    const resultBody = { statusCode: resultCode, message: 'Bad Request: Invalid resourceId {empty}!' }
                    const response: APIGatewayProxyResult = { statusCode: resultCode, body: JSON.stringify(resultBody) }
                    logResponse(context, response);
                    cb(null, response);
                    return;

                }

                const itemId = event.pathParameters.empresaId;
                const nosql = new NoSQL();
                nosql.getItem(tableName, itemId, function(err, data) {
        
                    if (err) {

                        const errMsg = { statusCode: 500, body: JSON.stringify(err) }
                        logResponse(context, errMsg);
                        const response: APIGatewayProxyResult = { statusCode: 500, body: JSON.stringify( {statusCode: 500, message: 'Internal Server Error!'}) }
                        logResponse(context, response);
                        cb(null, response);

                    } else {

                        logResponse(context, data);
                        cb(null, data);

                    }
        
                });

                break;

            }

            default: {

                const responseBody = { statusCode: 405, message: 'Method Not Allowed' };
                const response: APIGatewayProxyResult = { statusCode: 405, body: JSON.stringify(responseBody) }
                logResponse(context, response);
                cb(null, response);

            }

        }
    
    }

}